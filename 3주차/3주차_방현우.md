# 섹션7(자바 메모리 구조와 static)

## 자바 메모리 구조

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB7(%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20static)%20c72f123d924c4b80984ca3b691daa029/Untitled.png)

자바의 메모리 구조는 크게 메서드 영역, 스택 영역, 힙 영역 3개로 나눌 수 있다.

- 메서드 영역: 클래스 정보를 보관한다. 이 클래스 정보가 붕어빵 틀이다.
- 스택 영역: 실제 프로그램이 실행되는 영역이다. 메서드를 실행할 때 마다 하나씩 쌓인다.
- 힙 영역: 객체(인스턴스)가 생성되는 영역이다. new 명령어를 사용하면 이 영역을 사용한다. 쉽게 이야기해서 붕어빵 틀로부터 생성된 붕어빵이 존재하는 공간이다. 참고로 배열도 이 영역에 생성된다.

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB7(%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20static)%20c72f123d924c4b80984ca3b691daa029/Untitled%201.png)

- 메서드 영역(Method Area): 메서드 영역은 프로그램을 실행하는데 필요한 공통 데이터 관리. 프로그램의 모든 영역에서 공유
    - 클래스 정보: 클래스의 실행 코드(바이트 코드), 필드, 메서드와 생성자 코드등 모든 실행 코드가 존재한다
    - static 영역: static 변수들 보관
    - 런타임 상수 풀: 프로그램을 실행하는데 필요한 공통 리터럴 상수를 보관. 
    예를 들어서 프로그램에 "hello" 라는 리터럴 문자가 있으면 이런 문자를 공통으로 묶어서 관리한다. 이 외에도 프로그램을 효율적으로 관리하기 위한 상수들을 관리한다. (참고로 문자열을 다루는 문자열 풀은 자바 7부터 힙 영역으로 이동했다.)
- 스택 영역(Stack Area): 자바 실행 시, 하나의 실행 스택이 생성. 각 스택 프래임은 지역 변수, 중간 연산 결과, 메서드 호출 정보 등을 포함.
    - 스택 프레임: 스택 영역에 쌓이는 네모박스가 하나의 스택  프레임이다. 메서드를 호출 할 때 마다 하나의 스택 프레임이 쌓이고 메서드 종료시 프레임은 제거된다.
- 힙 영역(Heap Area): 객체와 인스턴스가 생성되는 영역. 가비지 컬렉션(GC)이 이루어지는 주요 영
역이며, 더 이상 참조되지 않는 객체는 GC에 의해 제거된다.

## 메서드 코드는 메서드 영역에

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB7(%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20static)%20c72f123d924c4b80984ca3b691daa029/Untitled%202.png)

## 스택과 큐 자료 구조

### 스택 구조

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB7(%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20static)%20c72f123d924c4b80984ca3b691daa029/Untitled%203.png)

블럭을 다음과 같이 생긴 통에 넣는다고 생각해보자. 위쪽만 열려있기 때문에 위쪽으로 블럭을 넣고, 위쪽으로 블럭을 빼야 한다. 쉽게 이야기해서 넣는 곳과 빼는 곳이 같다.

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB7(%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20static)%20c72f123d924c4b80984ca3b691daa029/Untitled%204.png)

블럭은 1 →2→ 3 순서대로 넣을 수 있다.

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB7(%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20static)%20c72f123d924c4b80984ca3b691daa029/Untitled%205.png)

블럭을 빼려면 위에서 부터 순서대로 빼야한다.
블럭은 3→ 2→ 1 순서로 뺄 수 있다.

정리하면 다음과 같다.
1(넣기) 2(넣기) 3(넣기) 3(빼기) 2(빼기) 1(빼기)

후입 선출(LIFO, Last In First Out)
여기서 가장 마지막에 넣은 3번이 가장 먼저 나온다. 이렇게 나중에 넣은 것이 가장 먼저 나오는 것을 후입 선출이라 하고, 이런 자료 구조를 스택이라 한다.

## 스택 영역

```java
package memory;
public class JavaMemoryMain1 {
public static void main(String[] args) {
 System.out.println("main start");
 method1(10);
 System.out.println("main end");
 }
 static void method1(int m1) {
 System.out.println("method1 start");
 int cal = m1 * 2;
 method2(cal);
 System.out.println("method1 end");
 }
 static void method2(int m2) {
 System.out.println("method2 start");
 System.out.println("method2 end");
 }
}

-----
main start
method1 start
method2 start
method2 end
method1 end
main end
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB7(%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20static)%20c72f123d924c4b80984ca3b691daa029/Untitled%206.png)

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB7(%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20static)%20c72f123d924c4b80984ca3b691daa029/Untitled%207.png)

## 스택 영역과 힙 영역

```java
package memory;
public class Data {
 private int value;
 public Data(int value) {
 this.value = value;
 }
 public int getValue() {
 return value;
 }
}
```

```java
package memory;
public class JavaMemoryMain2 {
 public static void main(String[] args) {
 System.out.println("main start");
 method1();
 System.out.println("main end");
 }
 static void method1() {
 System.out.println("method1 start");
 Data data1 = new Data(10);
 method2(data1);
 System.out.println("method1 end");
 }
 static void method2(Data data2) {
 System.out.println("method2 start");
 System.out.println("data.value=" + data2.getValue());
 System.out.println("method2 end");
 }
}
```

main() → method1() → method2() 순서로 호출하는 단순한 코드이다.
method1() 에서 Data 클래스의 인스턴스를 생성한다.
method1() 에서 method2() 를 호출할 때 매개변수에 Data 인스턴스의 참조값을 전달한다.

## Static 변수 1

static 키워드는 주로 멤버 변수와 메서드에 사용된다.

```java
package static1;
public class Data1 {
 public String name;
 public int count;
 public Data1(String name) {
 this.name = name;
 count++;
 }
}
```

```java
package static1;
public class DataCountMain1 {
 public static void main(String[] args) {
 Data1 data1 = new Data1("A");
 System.out.println("A count=" + data1.count);
 Data1 data2 = new Data1("B");
 System.out.println("B count=" + data2.count);
 Data1 data3 = new Data1("C");
 System.out.println("C count=" + data3.count);
 }
}

-----
A count=1
B count=1
C count=1
```

이 프로그램은 당연히 기대한 대로 작동하지 않는다. 객체를 생성할 때 마다 Data1 인스턴스는 새로 만들어진다. 그리고 인스턴스에 포함된 count 변수도 새로 만들어지기 때문이다.
인스턴스에 사용되는 멤버 변수 count 값은 인스턴스끼리 서로 공유되지 않는다. 따라서 원하는 답을 구할 수 없다. 이 문제를 해결하려면 변수를 서로 공유해야 한다.

## static 변수 2

```java
public class Data3 {
public String name;
 public static int count; //static 이렇게 멤버 변수에 static 을 붙이게 되면 static 변수, 정적 변수 또는 클래스 변수라 한다.
 public Data3(String name) {
 this.name = name;
 count++;
 }
```

```java
public class DataCountMain3 {
 public static void main(String[] args) {
 Data3 data1 = new Data3("A");
 System.out.println("A count=" + Data3.count);
 Data3 data2 = new Data3("B");
 System.out.println("B count=" + Data3.count);
 Data3 data3 = new Data3("C");
 System.out.println("C count=" + Data3.count);
 }
 //코드를 보면 count 정적 변수에 접근하는 방법이 조금 특이한데 Data3.count 와 같이 클래스명에 . (dot)을 사용한다. 마치 클래스에 직접 접근하는 것 처럼 느껴진다
 
 ------
A count=1
B count=2
C count=3
```

static 이 붙은 정적 변수에 접근하려면 Data3.count 와 같이 클래스명 + . (dot) + 변수명으로 접근하면 된다.
참고로 Data3 의 생성자와 같이 자신의 클래스에 있는 정적 변수라면 클래스명을 생략할 수 있다.

정리

static 변수는 쉽게 이야기해서 클래스인 붕어빵 틀이 특별히 관리하는 변수이다. 붕어빵 틀은 1개이므로 클래스 변수도 하나만 존재한다. 반면에 인스턴스 변수는 붕어빵인 인스턴스의 수 만큼 존재한다.

## static 변수3

이번에는 static 변수를 정리해보자.

```java
public class Data3 {
 public String name;
 public static int count; //static
}
```

- 멤버변수(필드) 종류
    - 인스턴스 변수: static이 붙지 않은 멤버 변수, 예)name
        - static 이 붙지 않은 멤버 변수는 인스턴스를 생성해야 사용할 수 있고, 인스턴스에 소속되어 있다. 따라서 인스턴스 변수라 한다.
        - 인스턴스 변수는 인스턴스를 만들 때마다 새로 만들어진다.
    - 클래스 변수: static이 붙은 멤버변수 예)count
        - 클래스 변수, 정적변수, static 변수 등으로 부른다.
        - static이 붙은 멤버 변수는 인스턴스와 무관하게 클래스에 바로 접근해서 사용할 수 있고, 클래스 자체에 소속되어 있다. 따라서 클래스 변수라 한다.
        - 클래스 변수는 자바 프로그램을 시작할 때 딱 1개가 만들어진다. 인스턴스와는 다르게 보통 여러곳에서 공유하는 목적으로 사용된다.

### 변수와 생성주기

- 지역변수(매개변수 포함): 지역변수는 스택 영역에 있는 스택 프레임 안에 보관됨. 메서드 종료시 스택프레임이 제거됨으로 그 안에 포함된 지역 변수도 함께 제거된다. ⇒ 생존 주기 짧음
- 인스턴스 변수: 인스턴스에 있는 멤버 변수를 인스턴스 변수라고 함. 인스턴스 변수는 힙 병역 사용.
- 클래스 변수: 메서드 영역의 static 영역에 보관되는 변수. 메서드 영역은 프로그램 전체에서 사용하는 공용 공간이다. 클래스 변수는 해당 클래스가 JVM에 로딩 되는 순간 생성된다. 그리고 JVM이 종료될때 까지 생명주기가 이어진다. 따라서 가장 긴 생명주기를 가진다.

static 이 정적이라는 이유는 바로 여기에 있다. 힙 영역에 생성되는 인스턴스 변수는 동적으로 생성되고, 제거된다.반면에 static 인 정적 변수는 거의 프로그램 실행 시점에 딱 만들어지고, 프로그램 종료 시점에 제거된다. 정적 변수는 이름 그대로 정적이다.

## static 메서드 1

### 인스턴스 메서드

```java
public class DecoUtil1 {
 public String deco(String str) {
 String result = "*" + str + "*";
 return result;
 }
}
```

```java
public class DecoMain1 {
 public static void main(String[] args) {
 String s = "hello java";
 DecoUtil1 utils = new DecoUtil1();
 String deco = utils.deco(s);
 System.out.println("before: " + s);
 System.out.println("after: " + deco);
 }
 ----
 before: hello java
after: *hello java*
```

### static 메서드

```java
public class DecoUtil2 {
 public static String deco(String str) {
 String result = "*" + str + "*";
 return result;
 }
}
```

```java
public class DecoMain2 {
 public static void main(String[] args) {
 String s = "hello java";
 String deco = DecoUtil2.deco(s);
 System.out.println("before: " + s);
 System.out.println("after: " + deco);
 }
}
```

static 이 붙은 정적 메서드는 객체 생성 없이 클래스명 + . (dot) + 메서드 명으로 바로 호출할 수 있다.
정적 메서드 덕분에 불필요한 객체 생성 없이 편리하게 메서드를 사용했다.

클래스 메서드

static 이 정적이라는 뜻이기 때문이고, 클래스 메서드라는 용어는 인스턴스 생성 없이 마치 클래스에 있는 메서드를 바로 호출하는 것 처럼 느껴지기 때문이다

인스턴스 메서드

static 이 붙지 않은 메서드는 인스턴스를 생성해야 호출할 수 있다. 이것을 인스턴스 메서드라 한다.

## static 메서드 2

### 정적 메서드 사용법

- static 메서드는 static만 사용할 수 있다.
    - 클래스 내부의 기능을 사용할 때 정적 메서드는 static 이 붙은 정적 메서드나 정적 변수만 사용할 수 있다.
    - static 이 붙은 정적 메서드나 정적 변수만 사용할 수 있다.
- 반대로 모든 곳에서 static 을 호출할 수 있다.
    - 정적 메서드는 공용 기능이다. 따라서 접근 제어자만 허락한다면 클래스를 통해 모든 곳에서 static 을 호출할 수 있다.

```java
public class DecoData {
 private int instanceValue;
 private static int staticValue;
 
 public static void staticCall() {
 //instanceValue++; //인스턴스 변수 접근, compile error
 //instanceMethod(); //인스턴스 메서드 접근, compile error
 staticValue++; //정적 변수 접근
 staticMethod(); //정적 메서드 접근
 }
 
// public static void staticCall(DecoData data) {다음과 같이 객체의 참조값을 직접 매개변수로 전달하면 정적 메서드도 인스턴스의 변수나 메서드를 호출할 수 있다.
// data.instanceValue++;
// data.instanceMethod();
//}
 
 public void instanceCall() {
 instanceValue++; //인스턴스 변수 접근
 instanceMethod(); //인스턴스 메서드 접근
 staticValue++; //정적 변수 접근
 staticMethod(); //정적 메서드 접근
 }
 
 private void instanceMethod() {
 System.out.println("instanceValue=" + instanceValue);
 }
 
 private static void staticMethod() {
 System.out.println("staticValue=" + staticValue);
 }
}
```

```java
package static2;
public class DecoDataMain {
public static void main(String[] args) {
 System.out.println("1.정적 호출");
 DecoData.staticCall();
 System.out.println("2.인스턴스 호출1");
 DecoData data1 = new DecoData();
 data1.instanceCall();
 
 System.out.println("3.인스턴스 호출2");
 DecoData data2 = new DecoData();
 data2.instanceCall();
 }
}
```

```java
1.정적 호출
staticValue=1
2.인스턴스 호출1
instanceValue=1
staticValue=2
3.인스턴스 호출2
instanceValue=1
staticValue=3
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB7(%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%AA%20static)%20c72f123d924c4b80984ca3b691daa029/Untitled%208.png)

# 섹션8(final)

## 파이널 변수와 상수

final 은 class , method 를 포함한 여러 곳에 붙을 수 있다

```java
public class FinalLocalMain {
 public static void main(String[] args) {
 //final 지역 변수1
 final int data1;
 data1 = 10; //최초 한번만 할당 가능
 //data1 = 20; //컴파일 오류
 //final 지역 변수2
 final int data2 = 10;
 //data2 = 20; //컴파일 오류
 method(10);
 }
 //final 매개변수
 static void method(final int parameter) {
 //parameter = 20; 컴파일 오류
 }
```

- 매개변수에 final 이 붙으면 메서드 내부에서 매개변수의 값을 변경할 수 없다. 따라서 메서드 호출 시점에 사용 된 값이 끝까지 사용된다.

```java
public class ConstructInit {
 final int value;
 public ConstructInit(int value) {
 this.value = value;
 }
}
```

final 을 필드에 사용할 경우 해당 필드는 생성자를 통해서 한번만 초기화 될 수 있다.

```java
//final 필드 - 필드 초기화
public class FieldInit {
 static final int CONST_VALUE = 10;
 final int value = 10;
}
```

- final 필드를 필드에서 초기화하면 이미 값이 설정되었기 때문에 생성자를 통해서도 초기화 할 수 없다. value 필드를 참고하자.
- static 변수에도 final 선언 가능하다
    - 상수는 대문자로 사용

```java
public class FinalFieldMain {
 public static void main(String[] args) {
 //final 필드 - 생성자 초기화
 System.out.println("생성자 초기화");
 ConstructInit constructInit1 = new ConstructInit(10);
 ConstructInit constructInit2 = new ConstructInit(20);
 System.out.println(constructInit1.value);
 System.out.println(constructInit2.value);
 //final 필드 - 필드 초기화
 System.out.println("필드 초기화");
 FieldInit fieldInit1 = new FieldInit();
 FieldInit fieldInit2 = new FieldInit();
 FieldInit fieldInit3 = new FieldInit();
 System.out.println(fieldInit1.value);
 System.out.println(fieldInit2.value);
 System.out.println(fieldInit3.value);
 //상수
 System.out.println("상수");
 System.out.println(FieldInit.CONST_VALUE);
 }
}
----
생성자 초기화
10
20
필드 초기화
10
10
10
상수
10
```

생성자 통해서 초기화 하면 각 인스턴스마다 다른 값으로 초기화 가능하다. 초기화 이후에는 final이 붙었기 때문에 초기화 불가능,

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB8(final)%2004285c1c2e6e4a629b03626f65bec387/Untitled.png)

- final 필드를 필드에서 초기화 하는 경우 오른쪽과 같은 값을 가진다.
- 여기서는 FieldInit 인스턴스 모든 value값이 10
- 모든 인스턴스가 같은 값을 사용하기 때문에 결과적으로 메모리 낭비, 중복이라 static 사용하는 것이 좋다

### static final

- FieldInit.MY_VALUE 는 static 영역에 존재한다. 그리고 final 키워드를 사용해서 초기화 값이 변하 지 않는다.
- static 영역은 단 하나만 존재하는 영역이다. MY_VALUE 변수는 JVM 상에서 하나만 존재하므로 앞서 설명한 중복과 메모리 비효율 문제를 모두 해결할 수 있다.

## final 변수와 상수2

### 상수(constant)

상수는 변하지 않고 항상 일정한 값을 가지는 수. 고정된 값을 나타낸다. 이런 이유로 static final 키워드 사용한다.

- 대문자 사용, 구분은 언더바_사용.
    - 일반적인 상수 구분 위해서
- 필드를 직접 접근해서 사용하기 위해서.
    - 상수는 값을 변경할 수 없다. 따라서 필드에 직접 접근해도 데이터가 변하는 문제 발생 X.
- 상수는 런타임 중 변경할 수 없어서 프로그램을 종료하고 코드 변경 후 다시 프로그램을 시작해야 적용된다.

```java
public class ConstantMain2 {
 public static void main(String[] args) {
 System.out.println("프로그램 최대 참여자 수 " + Constant.MAX_USERS);
 int currentUserCount = 999;
 process(currentUserCount++);
 process(currentUserCount++);
 process(currentUserCount++);
 }
 private static void process(int currentUserCount) {
 System.out.println("참여자 수:" + currentUserCount);
 if (currentUserCount > Constant.MAX_USERS) {
 System.out.println("대기자로 등록합니다.");
 } else {
 System.out.println("게임에 참가합니다.");
 }
 }
```

- Constant.MAX_USERS 상수를 사용했다. 만약 프로그램 최대 참여자 수를 변경해야 하면 Constant.MAX_USERS 의 상수 값만 변경하면 된다.
- 매직넘버 문제 해결.

## final 변수와 참조

final은 변수의 값을 변경하지 못하도록 막는다.

- 변수는 크게 기본형 변수와 참조형 변수가 있다.
- 기본형 변수는 10,20 같은 값을 보관하고, 참조형 변수는 객체의 참조값을 보관한다.
    - final을 기본형 변수에 사용하면 값을 변경할 수 있다.
    - final을 참조형 변수에 사용하면 값을 변경할 수 없다.

```java
public class Data {
 public int value;
}
```

```java
public class FinalRefMain {
 public static void main(String[] args) {
 final Data data = new Data();
 //data = new Data(); //final 변경 불가 컴파일 오류 
 //변수 선언 시점에 참조값 할당 했으므로 더는 참조값 변경 불가
 
 //참조 대상의 값은 변경 가능
 data.value = 10;
 System.out.println(data.value);
 data.value = 20;
 System.out.println(data.value);
 }
```

이는 참조형 변수에 들어 있는 참조값만 변경하지 못한다는 이야기 이다.

** 제약이 중요하다

# 섹션9(상속)

예제 코드를 보면서 시작해보자

패키지 위치가 중요하다

```java
package extends1.ex1;
public class ElectricCar {
 public void move() {
 System.out.println("차를 이동합니다.");
 }
 public void charge() {
 System.out.println("충전합니다.");
 }
}
```

```java
package extends1.ex1;
public class GasCar {
public void move() {
 System.out.println("차를 이동합니다.");
 }
 public void fillUp() {
 System.out.println("기름을 주유합니다.");
 }
}
```

```java
package extends1.ex1;
public class CarMain {
 public static void main(String[] args) {
 ElectricCar electricCar = new ElectricCar();
 electricCar.move();
 electricCar.charge();
 GasCar gasCar = new GasCar();
 gasCar.move();
 gasCar.fillUp();
 }
}
----
차를 이동합니다.
충전합니다.
차를 이동합니다.
기름을 주유합니다.
----
```

move라는 중복되는 것이 보인다. 이는 상속관계를 사용하는 것이 효과적이다.

## 상속관계

extends 대상은 하나만 설정 가능하다.

- 용어정리
    - 부모 클래스 (슈퍼 클래스)
    - 자식 클래스 (서브 클래스)

```java
package extends1.ex2;
public class Car {
 public void move() {
 System.out.println("차를 이동합니다.");
 }
}
```

Car는 부모 클래스가 된다. 공통기능인 move() 메서드 포함.

```java
package extends1.ex2;
public class ElectricCar extends Car {//Car 상속
 public void charge() {
 System.out.println("충전합니다.");
 }
}
```

Car을 상속하기 때문에 ElectricCar에서도 move()사용 가능

```java
package extends1.ex2;
public class GasCar extends Car {
 public void fillUp() {
 System.out.println("기름을 주유합니다.");
 }
}
```

Car을 상속하기 때문에 GasCar에서도 move()사용 가능

```java
package extends1.ex2;
public class CarMain {
 public static void main(String[] args) {
 ElectricCar electricCar = new ElectricCar();
 electricCar.move();
 electricCar.charge();
 GasCar gasCar = new GasCar();
 gasCar.move();
 gasCar.fillUp();
 }
}
----
차를 이동합니다.
충전합니다.
차를 이동합니다.
기름을 주유합니다.
----
실행결과 동일
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB9(%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8)%20ad4866353e6c4e9db6722fb6dc3cde03/Untitled.png)

부모는 자식 클래스 접근할 수 없다. 반면에 자식클래스는 부모가 누구인지 알기 때문에 접근 가능하다.

## 단일 상속

자바는 다중 상속을 지원하지 않아서 extends는 하나만 사용 가능하다.

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB9(%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8)%20ad4866353e6c4e9db6722fb6dc3cde03/Untitled%201.png)

만약 다중상속을 하게 되면 어떤 move()메서드를 사용해야 할지 애매한 문제가 발생하게 되는데 이 문제를 다이아몬드 문제라고 부른다. 이는 인터페이스의 다중 구현을 혀용해서 문제 해결이 가능하다.

## 상속과 메모리 구조

이 부분이 상당히 중요!!!!!!!!!

상속관계를 객체로 생성할 때 메모리 구조 확인

```java
ElectricCar electricCar = new ElectricCar();
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB9(%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8)%20ad4866353e6c4e9db6722fb6dc3cde03/Untitled%202.png)

new ElectricCar() 를 호출하면 ElectricCar 뿐만 아니라 상속 관계에 있는 Car 까지 함께 포함해서 인스턴스를 생성한다. 참조값은 x001로 하나이지만 두가지 클래스 정보가 공존하는 것이다. 상속관계를 사용하면 부모 클래스까지 함께 포함해서 생성된다.

외부에서 볼때는 하나의 인스턴스를 생성하는 것 같지만 내부에서는 부모와 자식이 모두 생성되고 공간도 구분된다.

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB9(%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8)%20ad4866353e6c4e9db6722fb6dc3cde03/Untitled%203.png)

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB9(%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8)%20ad4866353e6c4e9db6722fb6dc3cde03/Untitled%204.png)

## 상속과 기능 추가

공통된 기능을 추가하고 싶다면 부모 클래스에 메서드를 추가하면 된다.

## 상속과 메서드 오버라이딩

예를 들어서 자동차의 경우 Car.move() 라는 기능이 있다. 이 기능을 사용하면 단순히 "차를 이동합니다."라고 출력한다. 전기차의 경우 보통 더 빠르기 때문에 전치가가 move() 를 호출한 경우에는 "전기차를 빠르게 이동합니다."라고 출력을 변경하고 싶다.

메서드 오버라이딩: 부모에게 상속받은 기능을 자식이 재정의 하는 것.

```java
package extends1.overriding;
public class Car {
 public void move() {
 System.out.println("차를 이동합니다.");
 }
 public void openDoor() {
 System.out.println("문을 엽니다.");
 }
}
```

```java
package extends1.overriding;
public class GasCar extends Car {
 public void fillUp() {
 System.out.println("기름을 주유합니다.");
 }
}
```

```java
package extends1.overriding;
public class ElectricCar extends Car {
 @Override
 public void move() {
 System.out.println("전기차를 빠르게 이동합니다.");
 }
 public void charge() {
 System.out.println("충전합니다.");
 }
}
```

메서드 이름은 같지만 새로운 기능을 사용하고 싶다. 그래서 ElectricCar 의 move() 메서드를 새로 만들었다. 이렇게 부모의 기능을 자식이 새로 재정의하는 것을 메서드 오버라이딩이라 한다.
이제 ElectricCar 의 move() 를 호출하면 Car 의 move() 가 아니라 ElectricCar 의 move() 가 호출된다.

@Override

@ 이 붙은 부분을 애노테이션이라 한다. 애노테이션은 주석과 비슷한데, 프로그램이 읽을 수 있는 특별한 주석이라 생각하면 된다. 명확성을 위해서 붙혀주는게 좋다.

메서드 오버라이딩 조건

- 메서드 이름이 같아야 한다.
- 메서드 매개변수(파라미터) 타입, 순서, 개수가 같아야 한다.
- 반환 타입: 반환타입이 같아야 한다. 단, 반환타입이 하위 클래스 일 수 도 있다.
- 접근 제어자가 상위 클래스보다 더 제한적이면 안된다.
- 예외: 오버라이딩 메서드는 상위 클래스의 메서드보다 더 많은 예외를 throw로 선언할 수 없다.
- static, final, private 키워드 붙은 메서드는 오버라이딩 불가능
    - static은 클래스 레벨에서 작동하므로 인스턴스 레벨에서 작동하는 오버라이딩에서는 의미가 없다. 그냥 클래스로 접근해서 사용하면 된다.
    - final은 메서드 재정의 금지
    - private 메서드는 해당 클래스에서만 가능하기 때문에 하위클래스에서 보이지 않는다. 따라서 오버라이딩 불가
- 생성자 오버라이딩 불가능

## 상속과 접근 제어

```java
package extends1.access.parent;
public class Parent {
 public int publicValue;
 protected int protectedValue;
 int defaultValue;
 private int privateValue;
 public void publicMethod() {
 System.out.println("Parent.publicMethod");
 }
 protected void protectedMethod() {
 System.out.println("Parent.protectedMethod");
 }
 void defaultMethod() {
 System.out.println("Parent.defaultMethod");
 }
 private void privateMethod() {
 System.out.println("Parent.privateMethod");
 }
 public void printParent() {
 System.out.println("==Parent 메서드 안==");
 System.out.println("publicValue = " + publicValue);
 System.out.println("protectedValue = " + protectedValue);
 System.out.println("defaultValue = " + defaultValue); //부모 메서드 안에서 접근 가능
 System.out.println("privateValue = " + privateValue); //부모 메서드 안에서 접근 가능
 //부모 메서드 안에서 모두 접근 가능
 defaultMethod();
 privateMethod();
 }
}
```

```java
package extends1.access.child;
import extends1.access.parent.Parent;
public class Child extends Parent {
 public void call() {
 publicValue = 1;
 protectedValue = 1; //상속 관계 or 같은 패키지
 //defaultValue = 1; //다른 패키지 접근 불가, 컴파일 오류
 //privateValue = 1; //접근 불가, 컴파일 오류
 publicMethod();
 protectedMethod(); //상속 관계 or 같은 패키지
 //defaultMethod(); //다른 패키지 접근 불가, 컴파일 오류
 //privateMethod(); //접근 불가, 컴파일 오류
 printParent();
 }
	}
```

```java
package extends1.access;
import extends1.access.child.Child;
public class ExtendsAccessMain {
 public static void main(String[] args) {
 Child child = new Child();
 child.call();
 }
 
 ----
 Parent.publicMethod
Parent.protectedMethod
==Parent 메서드 안==
publicValue = 1
protectedValue = 1
defaultValue = 0
privateValue = 0
Parent.defaultMethod
Parent.privateMethod
----
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB9(%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8)%20ad4866353e6c4e9db6722fb6dc3cde03/Untitled%205.png)

## 부모 참조

부모와 자식의 필드명이 같거나 오버라이딩 되어 있으면, 자식에서 부모의 필드나 메서드 호출 불가.

이때 super키워드를 사용하면 부모를 참조할 수 있다. super은 부모 클래스에 대한 참조를 나타낸다.

```java
package extends1.super1;
public class Parent {
 public String value = "parent";
 public void hello() {
 System.out.println("Parent.hello");
 }
}
```

```java
package extends1.super1;
public class Child extends Parent {
 public String value = "child";
 @Override
 public void hello() {
 System.out.println("Child.hello");
 }
 public void call() {
 System.out.println("this value = " + this.value); //this 생략 가능
 System.out.println("super value = " + super.value);
 this.hello(); //this 생략 가능
 super.hello();
 }
}
```

필드 이름과 메서드 이름이 같지만 super 를 사용해서 부모 클래스에 있는 기능을 사용할 수 있다.

## super - 생성자

상속 관계의 인스턴스를 생성하면 결국 메모리 내부에는 자식과 부모 클래스가 각각 다 만들어진다. Child 를 만들면 부모인 Parent 까지 함께 만들어지는 것이다. 따라서 각각의 생성자도 모두 호출되어야 한다.

상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다.(규칙)

```java
package extends1.super2;
public class ClassA {
 public ClassA() {
 System.out.println("ClassA 생성자");
 }
}
```

```java
package extends1.super2;
public class ClassB extends ClassA {
 public ClassB(int a) {
 super(); //기본 생성자 생략 가능
 System.out.println("ClassB 생성자 a="+a);
 }
 public ClassB(int a, int b) {
 super(); //기본 생성자 생략 가능
 System.out.println("ClassB 생성자 a="+a + " b=" + b);
 }
}
```

ClassB 는 ClassA 를 상속 받았다. 상속을 받으면 생성자의 첫줄에 super(...) 를 사용해서 부모 클래스의 생성자를 호출해야 한다

부모 클래스의 생성자가 기본 생성자(파라미터가 없는 생성자)인 경우에는 super() 를 생략할 수 있다.

```java
package extends1.super2;
public class ClassC extends ClassB {
 public ClassC() {
 super(10, 20);//생성자는 하나만 호출할 수 있다. 두 생성자 중에 하나를 선택하면 된다
 System.out.println("ClassC 생성자");
 }
}
```

참고로 ClassC 의 부모인 ClassB 에는 기본 생성자가 없다. 따라서 부모의 기본 생성자를 호출하는
super() 를 사용하거나 생략할 수 없다

```java
package extends1.super2;
public class Super2Main {
 public static void main(String[] args) {
 ClassC classC = new ClassC();
 }
 }
 ---
 ClassA 생성자
ClassB 생성자 a=10 b=20
ClassC 생성자
---
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB9(%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8)%20ad4866353e6c4e9db6722fb6dc3cde03/Untitled%206.png)

# 섹션10(다형성1)

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB10(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC1)%20d91ec05951ad4ac5bc494efc6ebe4f1c/Untitled.png)

## 다형성 시작

이름 그대로 다양한 형태를 나타낸다.

다형성을 사용하면 하나의 객체가 다른 타입으로 사용될 수 있다는 뜻.

- 다형적 참조
- 메서드 오버라이딩

### 다형적 참조

부모와 자식이 있고 서로 다른 메서드 가질 때

```java
package poly.basic;
public class Parent {
 public void parentMethod() {
 System.out.println("Parent.parentMethod");
 }
}
```

```java
package poly.basic;
public class Child extends Parent {
 public void childMethod() {
 System.out.println("Child.childMethod");
 }
}
```

```java
package poly.basic;
/**
 * 다형적 참조: 부모는 자식을 품을 수 있다.
 */
public class PolyMain {
 public static void main(String[] args) {
 //부모 변수가 부모 인스턴스 참조
 System.out.println("Parent -> Parent");
 Parent parent = new Parent();
 parent.parentMethod();
 //자식 변수가 자식 인스턴스 참조
 System.out.println("Child -> Child");
 Child child = new Child();
 child.parentMethod();
 child.childMethod();
 //부모 변수가 자식 인스턴스 참조(다형적 참조)
 System.out.println("Parent -> Child");
 Parent poly = new Child();
 poly.parentMethod();
 //Child child1 = new Parent(); 자식은 부모를 담을 수 없다.
 //자식의 기능은 호출할 수 없다. 컴파일 오류 발생
 //poly.childMethod();
 }
}
----
Parent -> Parent
Parent.parentMethod
Child -> Child
Parent.parentMethod
Child.childMethod
Parent -> Child
Parent.parentMethod
----
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB10(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC1)%20d91ec05951ad4ac5bc494efc6ebe4f1c/Untitled%201.png)

부모는 자식을 담을 수 있다.

- Parent parent = new Parent(); 성공
- Child child = new Parent(); 실패

### 다형적 참조

Parent 타입 변수는 Parent타입은 물론 그 하위 타입까지 참조할 수 있다.

다형적 참조의 한계

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB10(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC1)%20d91ec05951ad4ac5bc494efc6ebe4f1c/Untitled%202.png)

상속 관계는 부모 관계에서 자식 관계로 내려갈 수 없다. 따라서 Parent 는 부모 타입이고 상위에 부모가 없다. 따라서 childMethod() 를 찾을 수 없으므로 컴파일 오류가 발생한다

childMethod를 호출하고 싶다면 캐스팅을 이용하면 된다.

## 다형성과 캐스팅

```java
package poly.basic;
public class CastingMain1 {
 public static void main(String[] args) {
 //부모 변수가 자식 인스턴스 참조(다형적 참조)
 Parent poly = new Child();
 //단 자식의 기능은 호출할 수 없다. 컴파일 오류 발생
 //poly.childMethod();
 //다운캐스팅(부모 타입 -> 자식 타입)
 Child child = (Child) poly;
 child.childMethod();
 }
}
```

다운 캐스팅

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB10(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC1)%20d91ec05951ad4ac5bc494efc6ebe4f1c/Untitled%203.png)

부모는 자식을 담을 수 있지만 자식은 부모를 담을 수 없다.

```java
Child child = (Child) poly //다운캐스팅을 통해 부모타입을 자식 타입으로 변환한 다음에 대입 시도
Child child = (Child) x001 //참조값을 읽은 다음 자식 타입으로 지정
Child child = x001 //최종 결과
```

캐스팅을 한다고 Parent poly의 값이 변하는게 아니라 꺼낸 참조값이 Child 타입이 되는것이다.

poly의 타입은 Parent로 기존과 같이 유지.

캐스팅

업캐스팅(upcasting): 부모 타입으로 변경
다운캐스팅(downcasting): 자식 타입으로 변경

## 캐스팅의 종류

다운 캐스팅 결과를 변수에 담아두고 이후에 기능을 사용하면 된다.

번거롭기 때문에 일시적 다운캐스팅 사용을 하기도 한다.

일시적 다운 캐스팅

```java
package poly.basic;
public class CastingMain2 {
 public static void main(String[] args) {
 //부모 변수가 자식 인스턴스 참조(다형적 참조)
 Parent poly = new Child();
 //단 자식의 기능은 호출할 수 없다. 컴파일 오류 발생
 //poly.childMethod();
 //일시적 다운캐스팅 - 해당 메서드를 호출하는 순간만 다운캐스팅
 ((Child) poly).childMethod();
 }
}
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB10(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC1)%20d91ec05951ad4ac5bc494efc6ebe4f1c/Untitled%204.png)

## 업캐스팅

```java
package poly.basic;
//upcasting vs downcasting
public class CastingMain3 {
 public static void main(String[] args) {
 Child child = new Child();
 Parent parent1 = (Parent) child; //업캐스팅은 생략 가능, 생략 권장
 Parent parent2 = child; //업캐스팅 생략
 parent1.parentMethod();
 parent2.parentMethod();
 }
}
```

업캐스팅은 생략할 수 있다. 다운캐스팅은 생략할 수 없다. 참고로 업캐스팅은 매우 자주 사용하기 때문에 생략을 권장한다.

## 다운캐스팅 주의점

```java
package poly.basic;
//다운캐스팅을 자동으로 하지 않는 이유
public class CastingMain4 {
 public static void main(String[] args) {
 Parent parent1 = new Child();
 Child child1 = (Child) parent1;
 child1.childMethod(); //문제 없음
 
 Parent parent2 = new Parent();
 Child child2 = (Child) parent2; //런타임 오류 - ClassCastException
 child2.childMethod(); //실행 불가
 }
}
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB10(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC1)%20d91ec05951ad4ac5bc494efc6ebe4f1c/Untitled%205.png)

메모리 상에 자식 타입이 전혀 존재하지 않기 때문에 Child자체를 사용할 수 없다.]

다운캐스팅의 경우 인스턴스에 존재하지 않는 하위 타입으로 캐스팅하는 문제가 발생할 수 있다. 왜냐하면 객체를 생성하면 부모 타입은 모두 함께 생성되지만 자식 타입은 생성되지 않는다. 따라서 개발자가 이런 문제를 인지하고 사용해야 한다는 의미로 명시적으로 캐스팅을 해주어야 한다.

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB10(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC1)%20d91ec05951ad4ac5bc494efc6ebe4f1c/Untitled%206.png)

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB10(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC1)%20d91ec05951ad4ac5bc494efc6ebe4f1c/Untitled%207.png)

## instanceof

참조하는 인스턴스가 어떤건지 확인하는데 사용.

```java
package poly.basic;
public class CastingMain5 {
 public static void main(String[] args) {
 Parent parent1 = new Parent();
 System.out.println("parent1 호출");
 call(parent1);
 Parent parent2 = new Child();
 System.out.println("parent2 호출");
 call(parent2);
 }
 private static void call(Parent parent) {
 parent.parentMethod();
 if (parent instanceof Child) {
 System.out.println("Child 인스턴스 맞음");
 Child child = (Child) parent;
 child.childMethod();
 }
 }
}
----
parent1 호출
Parent.parentMethod
parent2 호출
Parent.parentMethod
Child 인스턴스 맞음
Child.childMethod
----
```

다운캐스팅을 수행하기 전에는 먼저 instanceof 를 사용해서 원하는 타입으로 변경이 가능한지 확
인한 다음에 다운캐스팅을 수행하는 것이 안전

```java
parent instanceof Parent //parent는 Child의 인스턴스
new Parent() instanceof Parent //parent가 Parent의 인스턴스를 참조하는 경우: true
new Child() instanceof Parent //parent가 Child의 인스턴스를 참조하는 경우: true
```

자바 16 - Pattern Matching for instanceof

instanceof 를 사용하면서 동시에 변수를 선언할 수 있다.

```java
package poly.basic;
public class CastingMain6 {
 public static void main(String[] args) {
 Parent parent1 = new Parent();
 System.out.println("parent1 호출");
 call(parent1);
 Parent parent2 = new Child();
 System.out.println("parent2 호출");
 call(parent2);
 }
 private static void call(Parent parent) {
 parent.parentMethod();
 //Child 인스턴스인 경우 childMethod() 실행
 if (parent instanceof Child child) {
 System.out.println("Child 인스턴스 맞음");
 child.childMethod();
 }
 }
}
```

## 다형성과 메서드 오버라이딩

메서드 오버라이딩에서 꼭! 기억해야 할 점은 오버라이딩 된 메서드가 항상 우선권을 가진다는 점

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB10(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC1)%20d91ec05951ad4ac5bc494efc6ebe4f1c/Untitled%208.png)

멤버변수(value)는 오버라이딩 되지 않는다.

```java
**package poly.overriding;
public class Parent {
 public String value = "parent";
 public void method() {
 System.out.println("Parent.method");
 }
}**
```

```java
package poly.overriding;
public class Child extends Parent {
 public String value = "child";
 @Override
 public void method() {
 System.out.println("Child.method");
 }
}
```

```java
package poly.overriding;
public class OverridingMain {
 public static void main(String[] args) {
 //자식 변수가 자식 인스턴스 참조
 Child child = new Child();
 System.out.println("Child -> Child");
 System.out.println("value = " + child.value);
 child.method();
 //부모 변수가 부모 인스턴스 참조
 Parent parent = new Parent();
 System.out.println("Parent -> Parent");
 System.out.println("value = " + parent.value);
 parent.method();
 //부모 변수가 자식 인스턴스 참조(다형적 참조)
 Parent poly = new Child();
 System.out.println("Parent -> Child");
 System.out.println("value = " + poly.value); //변수는 오버라이딩X
 poly.method(); //메서드 오버라이딩!
 }
}
----
Child -> Child
value = child
Child.method
Parent -> Parent
value = parent
Parent.method
Parent -> Child
value = parent
Child.method
----
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB10(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC1)%20d91ec05951ad4ac5bc494efc6ebe4f1c/Untitled%209.png)

오버라이딩 된 메서드는 항상 우선권을 갖는다.

용어 정리

- 다형적 참조:  하나의 변수 타입으로 다양한 자식 인스턴스를 참조할 수 있는 기능
- 메서드 오버라이딩: 기존 기능을 하위 타입에서 새로운 기능으로 재정의

# 섹션11(다형성2)

## 다형성 활용

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB11(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC2)%20705bb329f2824b9fb50573164546d587/Untitled.png)

Animal이라는 부모 클래스 만든 sound() 메서드 정의 ← 오버라이딩이 목적이다.

```java
package poly.ex2;
public class Animal {
 public void sound() {
 System.out.println("동물 울음 소리");
 }
}
```

```java
package poly.ex2;
public class Dog extends Animal {
@Override
 public void sound() {
 System.out.println("멍멍");
 }
}
```

```java
package poly.ex2;
public class Cat extends Animal {
 @Override
 public void sound() {
 System.out.println("냐옹");
 }
}
```

```java
package poly.ex2;
public class Caw extends Animal{
 @Override
 public void sound() {
 System.out.println("음매");
 }
}
```

```java
package poly.ex2;
public class AnimalPolyMain1 {
 public static void main(String[] args) {
 Dog dog = new Dog();
 Cat cat = new Cat();
 Caw caw = new Caw();
 soundAnimal(dog);
 soundAnimal(cat);
 soundAnimal(caw);
 }
 //동물이 추가 되어도 변하지 않는 코드
 private static void soundAnimal(Animal animal) {
 System.out.println("동물 소리 테스트 시작");
 animal.sound();
 System.out.println("동물 소리 테스트 종료");
 }
}
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB11(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC2)%20705bb329f2824b9fb50573164546d587/Untitled%201.png)

다형적 참조 때문에 필요한 부분을 사용할 수 있게 되었다.

배열과 for문을 이용해 중복을 더 제거할 수 있다.

```java
package poly.ex2;
public class AnimalPolyMain2 {
 public static void main(String[] args) {
 Dog dog = new Dog();
 Cat cat = new Cat();
 Caw caw = new Caw();
 Animal[] animalArr = {dog, cat, caw};
 //변하지 않는 부분
 for (Animal animal : animalArr) {
 System.out.println("동물 소리 테스트 시작");
 animal.sound();
 System.out.println("동물 소리 테스트 종료");
 }
 }
}
```

개선:

```java
package poly.ex2;
public class AnimalPolyMain2 {
 public static void main(String[] args) {
 Animal[] animalArr = {new Dog(), new Cat(), new Caw()};
 //변하지 않는 부분
 for (Animal animal : animalArr) {
soundAnimal(animal);
 }
 }
 
 //동물이 추가 되어도 변하지 않는 코드
 private static void soundAnimal(Animal animal) {
 System.out.println("동물 소리 테스트 시작");
 animal.sound();
 System.out.println("동물 소리 테스트 종료");
 }
}
```

Animal클래스 생성할 수 있는 문제, Animal클래스 상속하는 곳에서 sound메서드 오버라이딩 하지 않을 문제점

## 추상 클래스1

추상 클래스

동물( Animal )과 같이 부모 클래스는 제공하지만, 실제 생성되면 안되는 클래스를 추상 클래스라 한다

따라서 실체인 인스턴스가 존재하지 않는다. 대신에 상속을 목적으로 사용되고, 부모 클래스 역할을 담당한다.

```java
abstract class AbstractAnimal {...}
```

추상 메서드

부모 클래스를 상속 받는 자식 클래스가 반드시 오버라이딩 해야 하는 메서드를 부모 클래스에 정의할 수 있다. 바디가 없고 실체가 존재하지 않는다.

```java
public abstract void sound();
```

- 추상 메서드가 하나라도 있는 클래스는 추상 클래스로 선언해야 한다.
- 추상 메서드는 상속 받는 자식 클래스가 반드시 오버라이딩 해서 사용해야 한다.
- 추상 메서드는 기존 메서드와 완전히 같다. 다만 메서드 바디가 없고, 자식 클래스가 해당 메서드를 반드시 오버라이딩 해야 한다는 제약이 추가된 것이다.

```java
package poly.ex4;
public abstract class AbstractAnimal {
 public abstract void sound();
 public abstract void move();
}
```

```java
package poly.ex4;
public class Dog extends AbstractAnimal {
 @Override
 public void sound() {
 System.out.println("멍멍");
 }
 @Override
 public void move() {
 System.out.println("개 이동");
 }
}
```

```java
package poly.ex4;
public class Cat extends AbstractAnimal {
 @Override
 public void sound() {
 System.out.println("냐옹");
 }
 @Override
 public void move() {
 System.out.println("고양이 이동");
 }
}
```

```java
package poly.ex4;
public class Caw extends AbstractAnimal {
 @Override
 public void sound() {
 System.out.println("음매");
 }
 @Override
 public void move() {
 System.out.println("소 이동");
 }
}
```

```java
package poly.ex4;
public class AbstractMain {
 public static void main(String[] args) {
 Dog dog = new Dog();
 Cat cat = new Cat();
 Caw caw = new Caw();
 soundAnimal(cat);
 soundAnimal(dog);
 soundAnimal(caw);
 moveAnimal(cat);
 moveAnimal(dog);
 moveAnimal(caw);
 }
 //동물이 추가 되어도 변하지 않는 코드
 private static void soundAnimal(AbstractAnimal animal) {
 System.out.println("동물 소리 테스트 시작");
 animal.sound();
 System.out.println("동물 소리 테스트 종료");
 }
 //동물이 추가 되어도 변하지 않는 코드
 private static void moveAnimal(AbstractAnimal animal) {
 System.out.println("동물 이동 테스트 시작");
 animal.move();
 System.out.println("동물 이동 테스트 종료");
 }
}
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB11(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC2)%20705bb329f2824b9fb50573164546d587/Untitled%202.png)

### 순수 추상 클래스

모든 메서드가 추상 메서드인 순수 추상 클래스는 코드를 실행할 바디 부분이 없다.

⇒ 인터페이스 라는 기능 사용

```java
public interface InterfaceAnimal {
 void sound(); // public abstract 생략 가능
 public abstract void move();
}
```

- 인터페이스의 메서드는 모두 public, abstract 이다.
- 메서드에 public abstract 를 생략할 수 있다. 참고로 생략이 권장된다.
- 인터페이스는 다중 구현(다중 상속)을 지원한다

인터페이스에서 멤버 변수는 public , static , final 이 모두 포함되었다고 간주된다

## 인터페이스 - 다중 구현

```java
package poly.diamond;
public interface InterfaceA {
 void methodA();
 void methodCommon();
}
```

```java
package poly.diamond;
public interface InterfaceB {
 void methodB();
 void methodCommon();
}
```

```java
package poly.diamond;
public class Child implements InterfaceA, InterfaceB {
 @Override
 public void methodA() {
 System.out.println("Child.methodA");
 }
 @Override
 public void methodB() {
 System.out.println("Child.methodB");
 }
 @Override
 public void methodCommon() {
 System.out.println("Child.methodCommon");
 }
}
```

```java
package poly.diamond;
//인터페이스 다중 구현
public class DiamondMain {
 public static void main(String[] args) {
 InterfaceA a = new Child();
 a.methodA();
 a.methodCommon();
 InterfaceB b = new Child();
 b.methodB();
 b.methodCommon();
 }
}
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB11(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC2)%20705bb329f2824b9fb50573164546d587/Untitled%203.png)

1. a.methodCommon() 을 호출하면 먼저 x001 Child 인스턴스를 찾는다
2. 변수 a 가 InterfaceA 타입이므로 해당 타입에서 methodCommon() 을 찾는다.
3. methodCommon() 은 하위 타입인 Child 에서 오버라이딩 되어 있다. 따라서 Child 의 methodCommon() 이 호출된다

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB11(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC2)%20705bb329f2824b9fb50573164546d587/Untitled%204.png)

1. b.methodCommon() 을 호출하면 먼저 x001 Child 인스턴스를 찾는다.
2. 변수 b 가 InterfaceB 타입이므로 해당 타입에서 methodCommon() 을 찾는다.
3. methodCommon() 은 하위 타입인 Child 에서 오버라이딩 되어 있다. 따라서 Child 의 methodCommon() 이 호출된다

## 클래스와 인터페이스 활용

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB11(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC2)%20705bb329f2824b9fb50573164546d587/Untitled%205.png)

```java
package poly.ex6;
public abstract class AbstractAnimal {
 public abstract void sound();
 public void move() {
 System.out.println("동물이 이동합니다.");
 }
}
```

```java
package poly.ex6;
public interface Fly {
 void fly();
}
```

```java
package poly.ex6;
public class Dog extends AbstractAnimal {
 @Override
 public void sound() {
 System.out.println("멍멍");
 }
}
```

```java
package poly.ex6;
public class Bird extends AbstractAnimal implements Fly {
 @Override
 public void sound() {
 System.out.println("짹짹");
 }
 @Override
 public void fly() {
 System.out.println("새 날기");
 }
}
```

```java
package poly.ex6;
public class Chicken extends AbstractAnimal implements Fly {
 @Override
 public void sound() {
 System.out.println("꼬끼오");
 }
 @Override
 public void fly() {
 System.out.println("닭 날기");
 }
}
```

```java
package poly.ex6;
public class SoundFlyMain {
 public static void main(String[] args) {
 Dog dog = new Dog();
 Bird bird = new Bird();
 Chicken chicken = new Chicken();
 soundAnimal(dog);
 soundAnimal(bird);
 soundAnimal(chicken);
 flyAnimal(bird);
 flyAnimal(chicken);
 }
 //AbstractAnimal 사용 가능
 private static void soundAnimal(AbstractAnimal animal) {
 System.out.println("동물 소리 테스트 시작");
 animal.sound();
 System.out.println("동물 소리 테스트 종료");
 }
 //Fly 인터페이스가 있으면 사용 가능
 private static void flyAnimal(Fly fly) {
 System.out.println("날기 테스트 시작");
 fly.fly();
 System.out.println("날기 테스트 종료");
 }
}
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB11(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC2)%20705bb329f2824b9fb50573164546d587/Untitled%206.png)

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB11(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC2)%20705bb329f2824b9fb50573164546d587/Untitled%207.png)

오버라이딩 된 메서드가 우선이다!!!

# 섹션12(다형성과 설계)

역할과 구현을 분리해라.

객체 설계시 역할(인터페이스)를 먼저 부여하고 그 역할을 수행하는 구현 객체 만들기

객체의 협력이라는 관계부터 생각

클라이언트: 요청, 서버: 응답

## 다형성 - 역할과 구현 예제

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB12(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8)%209abe6a5344a142b6bd57059235775f7b/Untitled.png)

```java
package poly.car1;
public interface Car {
 void startEngine();
 void offEngine();
 void pressAccelerator();
}
```

```java
package poly.car1;
public class K3Car implements Car {
 @Override
 public void startEngine() {
 System.out.println("K3Car.startEngine");
 }
 @Override
 public void offEngine() {
 System.out.println("K3Car.offEngine");
 }
 @Override
 public void pressAccelerator() {
 System.out.println("K3Car.pressAccelerator");
 }
}
```

```java
package poly.car1;
public class Model3Car implements Car {
 @Override
 public void startEngine() {
 System.out.println("Model3Car.startEngine");
 }
 @Override
 public void offEngine() {
 System.out.println("Model3Car.offEngine");
 }
 @Override
 public void pressAccelerator() {
 System.out.println("Model3Car.pressAccelerator");
 }
}
```

```java
package poly.car1;
public class Driver {
 private Car car;
 public void setCar(Car car) {
 System.out.println("자동차를 설정합니다: " + car);
 this.car = car;
 }
 public void drive() {
 System.out.println("자동차를 운전합니다.");
 car.startEngine();
 car.pressAccelerator();
 car.offEngine();
 }
}
```

```java
package poly.car1;
/**
 * 다형성을 활용한 런타임 변경
 * 런타임: 애플리케이션 실행 도중에 변경 가능
 */
public class CarMain1 {
 public static void main(String[] args) {
 Driver driver = new Driver();
 //차량 선택(k3)
 Car k3Car = new K3Car();
 driver.setCar(k3Car);
 driver.drive();
 //차량 변경(k3 -> model3)
 Car model3Car = new Model3Car();
 driver.setCar(model3Car);
 driver.drive();
 }
}
```

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB12(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8)%209abe6a5344a142b6bd57059235775f7b/Untitled%201.png)

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB12(%E1%84%83%E1%85%A1%E1%84%92%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8)%209abe6a5344a142b6bd57059235775f7b/Untitled%202.png)

## OCP(Open-Closed Principle) 원칙

Open for extension:  새로운 기능의 추가나 변경 사항이 생겼을 때, 기존 코드는 확장할 수 있어야 한다

Closed for modification: 기존의 코드는 수정되지 않아야 한다